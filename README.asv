edbv
====

Programmablauf√ºberlegungen
--------------------------
* Import Video
* Einzelne Frames durchgehen
* Tisch ausschneiden (maske erstellen)
* B√§lle segmentieren, also als resultat soll eine Liste an Masken entstehen die position und form der einzelnen B√§lle widerspiegeln. (Connected Component Labeling, Cluster, Glanzlichter, usw.)
* Auf basis jeweils zweier Frames mit Optical Flow die Geschwindigkeitvektoren ermitteln.
* F√ºr jede Komponente eine mittlere Geschwindigkeit errechnen und mit hilfe dieser den selbe Komponente im n√§chsten Frame wiedererkennen.
* Das Resultat ist f√ºr jeden Frame eine Liste mit Komponent-Positionen/Masken
* Auf basis dieser Informationen k√∂nnen Outputs generiert werden (Bild mit linien, geschwindigkeiten, usw.)

Funktionen und Schnittstellen, Ablauf
-------------------------------------
Vorbearbeitung: 
* Video Einlesen
* Maske f√ºr Tisch <- Funktion zum Ausschneiden. Input: 1. Frame des Videos
**(Max)**

* VektorMatrix anlegen die f√ºr jeden Frame f√ºr jeden Ball einen Positionsvektor speichert
* VektorMatrix anlegen die f√ºr jeden Frame f√ºr jeden Ball einen Richtungsvektor speichert

Schleife l√§uft √ºber jeden Frame im Video:
* Component Labeling auf Frame anwenden Input: Video-Frame Output: Maske in der alle B√§lle eindeutig via farben gekennzeichnet sind.
 => Genauer Durchlauf mittels Glanzlichtern: Eingabe: Jede Component als Bild (volle Gr√∂√üe), Originalbild; Ausgabe: Die einzelnen Kugeln als Bild
**(Theresa)**

* Beim ersten durchlauf werden lediglich die Components erkannt
**(Florian, Theresa)**

* Optimieren der Erkennung der Gr√ºnen Kugel
**(Max)**

* Erstellen der Positions- und Richtungsvektorliste, Farbe der Components mitteln und in Lookup-Tabelle schreiben 
**(Florian, Gerald)**

* Bei allen weiteren durchl√§ufen wird die letzte Positions- und Richtungs-vektor-liste verwendet um m√∂glichst die neu erkannten Components wieder den gleichen Components vom letzten Frame exakt zuordnen zu k√∂nnen.

* OpticalFlow anwenden Input: Video-Frame Output: Matrix in der f√ºr einen Raster √ºber dem Bild jeweils Richtungsvektoren gespeichert sind.
**(Andreas, Gerald)**

* Component-Flow-Matching funktion anwenden Input: Component-Maske, OpticalFlow-Matrix, Output: Array mit Richtungsvektoren der einzelnen Components
**(Andreas, Gerald)**

* Funktion anwenden die Position der Components bestimmt: Input Component-Maske Output: Array mit Positionsvektoren der einzelnen Components
**(Gerald)**

* Positionsvektoren und Richtungsvektoren zu den Frame-√úbergreifenden Matrizen hinzuf√ºgen.
**(Gerald)**

Nachbearbeitung: 
* Funktion die basierend auf den Component Positionen und Richtungen der einzelnen Frames Linien in den korrekten Farben √ºber den letzten Frame des Videos zeichnet. Input: VektorMatrix der Component Positionen, VektorMatrix der Component Richtungen, Letzter Video-Frame. Output: Bild mit dar√ºbergelegten Linien.
**(im Prinzip fertig; Gerald, Andreas)**

| Update: 05.12.2013 - Neue vorgehensweise zum Erkennen der passenden Components im folgenden Frame |
1. Optical Flow durchf¸hren
2. Optical Flow Raster in Richtungen klassifizieren. 
3. F¸r jede gefundene Richtungs-Klasse wird eine maske erstellt, bei der ein dynamischer Threshold verwendet wird um nur relevante geschwindigkeiten zu ber¸cksichtigen.
4. Auf jede dieser Masken wird component-labeling angewandt.
5. F¸r jedes dieser Components werden Schnittpunkte von Kreisfˆrmigen arealen um die Mittelpunkte der Components berechnet.
6. F¸r jeden dieser Schnittpunkte werden mittlere geschwindigkeiten aus den beteiligten arealen berechnet.
7. In einem Kreisfˆrmigen Areal um diesen Schnittpunkt wird nach bekannten Positionen von "Ball"-Komponenten aus dem vorherigen Frame gesucht.
8. F¸r jede dieser Positionen wird eine neue position mithilfe der mittleren geschwindigkeit vorhergesagt.
9. um die vorhergesagte neue position herum wird mittels component labeling nach Ball-komponenten gesucht.
10. Falls mehrere Ballkomponenten gefunden werden wird die mit dem geringsten abstand zur vorhergesagten position gew‰hlt.
11. Die neue Position der gew‰hlten komponente wird als folge-position der alten position gesetzt.
Falls bei Punkt 7 bekannte Position im areal zu finden ist wird sofort mit punkt 

| Update: 11.11.2013 - Offene Punkte |
--------------------------------------

**Main:**
- VektorMatrix anlegen die f√ºr jeden Frame f√ºr jeden Ball einen Positionsvektor speichert
- VektorMatrix anlegen die f√ºr jeden Frame f√ºr jeden Ball einen Richtungsvektor speichert
- Ersten ComponentLabeling-Aufruf starten
- Neue Positionen in die Matrix schreiben (Funktion verwenden)
- Weitere Durchl√§ufe mittels ‚Äúvermutlicher‚Ä? Position (anhand der alten Positionen und OpticalFlow)
- Positions- und Richtungsvektoren schreiben (=> wenn eine Kugel in einem Loch verschwindet, m√ºssen trotzdem Werte in die Matrix geschrieben werden: letzter Wert (bei Positionsvektoren) bzw. 0 (bei Richtungsvektoren)

**Funktionen und Programmteile:**
- Funktion zum Ermitteln der neuen (zu erwartenden) Position einer Komponente. Eingabe: Maske der Componente, Richtungsvektor, Unsicherheitsfaktor, Originalbild; Ausgabe: Neue Maske;
- Zuverl√§ssigkeit der Kugelerkennung (Gr√ºn)
- Farben f√ºr die Eintr√§ge der Matrix hinterlegen (zum Nachzeichnen der Vektoren) => Funktionen zum Zeichnen der Linien soll die Farben ber√ºcksichtigen
- Funktion zum Anwenden von OpticalFlow. Eingabe: Video-Frame; Ausgabe: Matrix mit Richtungsvektoren f√ºr einen Raster √ºber dem Bild;
- Funktion zum Matchen von Component-Flow. Eingabe: Component-Maske, OpticalFlow-Matrix; Ausgabe: Array mit Richtungsvektoren der einzelnen Components;
- Funktion zum Anlegen der Matrix f√ºr die  Farben (die Reihenfolge muss der Reihenfolge der Kugeln entsprechen)
- Funktion, die die Vektormatrix der Positionsvektoren definiert (mit Anzahl der Kugeln)
- Funktion, die der Vektormatrix der Positionsvektoren einen Eintrag (pro Frame) f√ºr eine Kugel hinzuf√ºgt
- Funktion, die die Vektormatrix der Richtungsvektoren definiert (mit Anzahl der Kugeln)
- Funktion, die der Vektormatrix der Richtungsvektoren einen Eintrag (pro Frame) f√ºr eine Kugel hinzuf√ºgt
‚áí evtl. Richtungs- und Positionsmatrix zusammenlegen (1 Vektor mit 4 Eintr√§gen => Die beiden ersten Eintr√§ge entsprechen der Position und die nachfolgenden dem Richtungsvektor)
